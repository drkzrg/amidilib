
#    Copyright 2007-2017 Pawel Goralski
#    e-mail: pawel.goralski@nokturnal.pl
#    This file is part of AMIDILIB.
#    See license.txt for licensing information.

import sys
import os

env = Environment(tools=['default'])

Help("AMIDILIB Copyright 2007-2017 Pawel Goralski\n \
Type: 'Set build variables in SConstruct'\n \
where name of 'TARGET_MACHINE' can be: \n \
	'F030' - for Atari Falcon030 / TT build\n \
	'ST' - for Atari ST build \n \
	'CT60' - for Atari Falcon CT60/63\n \
 'USE_CROSSCOMPILER' - enables m68k cross compiler, set to 'y' by default\n \
 'BUILD_MODE' - build type ('debug', 'release'),\n \
 'USE_FPU' - enable/disable hardware fpu code generation (valid only on F030 builds),\n \
 'TX_ENABLE' - skips writing to ACIA ikbd port, sending bytes is via ikbd tx interrupt,\n \
 'CONOUT_ENABLE' - disable / enable console output,\n \
 'GEMDOS_IO_ENABLE' - uses gemdos i/o instead of standard libc file i/o,\n \
 'USE_LIBC' - if set to 'no', builds library without libc dependencies, reducing binary size,\n \
 'ENABLE_LTO' - eneable link time optimisation. Only valid on gcc 6.2 brownelf.\n \
 'DEBUG_LEVEL' - sets debug level, only valid in debug builds. Level can be set to (0..2), \n")

Import('TARGET_MACHINE',\
		'BUILD_MODE',\
		'IKBD_DIRECT_WRITE',\
		'USE_FPU',\
		'TX_ENABLE',\
		'CONOUT_ENABLE',\
		'GEMDOS_IO_ENABLE',\
		'USE_LIBC',\
		'ENABLE_LTO',\
		'USE_CROSSCOMPILER',\
		'TOOLSET',\
		'DEBUG_LEVEL')

# helper function, calls external tool (brownout) to convert elf files to tos executables		
def convertElf(prgName, buildMode, outputDirPath, ext):
	OUTDIR = ''
	symbolGeneration=''
	OutDirPath = Dir('../').abspath
		
	if(buildMode=='debug'):
		symbolGeneration=' -x'
		OUTDIR = outputDirPath + '/bin/' 
	else:
		OUTDIR = outputDirPath + '/bin/'  
		
	print('Converting: '+prgName + env['PROGSUFFIX'] +' -> ' + prgName + ext)
	
	tosBinary = env.Command(prgName + ext , None, 'brownout -i '+ OUTPUT_DIR + prgName + env['PROGSUFFIX'] + ' -o ' + OUTPUT_DIR + prgName + ext + symbolGeneration)
	env.AlwaysBuild(tosBinary)
	return	
 
build_mode = BUILD_MODE
use_crosscompiler = USE_CROSSCOMPILER
targetPlatform = TARGET_MACHINE
ikbd_direct_write = IKBD_DIRECT_WRITE
tx_enable = TX_ENABLE
conout_enable = CONOUT_ENABLE
gemdos_io_enable = GEMDOS_IO_ENABLE
use_libc = USE_LIBC
debug_level = DEBUG_LEVEL
enable_lto = ENABLE_LTO
use_fpu = USE_FPU

# environment 
compilerName=''
LIBRARYNAME = 'amidi'
PREFIX=''

if(TOOLSET=='GCC434'):
# Cygwin path
	PREFIX = '/opt/cross-mint'
# Linux cross compiler
# PREFIX = /usr
	compilerName = 'm68k-atari-mint-'
	env['CPPPATH'] = [PREFIX + 'm68k-atari-mint/include']
	env['LIBPATH'] = [PREFIX + 'm68k-atari-mint/lib']
elif(TOOLSET=='GCC710'):
# Linux/Cygwin cross compiler
    PREFIX = '/usr'
    compilerName = 'm68k-ataribrowner-elf-'
    env['CPPPATH'] = [PREFIX + '/m68k-ataribrowner-elf/include']
    env['LIBPATH'] = [PREFIX + '/m68k-ataribrowner-elf/lib']
else:
    print('ERROR: Undefined target toolset. Exiting...')
    exit(-1)

env['CC'] = PREFIX + '/bin/' + compilerName + 'gcc'
env['CXX'] = PREFIX + '/bin/' + compilerName + 'g++'
env['OBJCOPY'] = PREFIX + '/bin/' + compilerName + 'objcopy'
env['STRIP'] = PREFIX + '/bin/' + compilerName + 'strip -s'
env['STACK'] = PREFIX + '/bin/' + compilerName + 'stack'
env['AR'] = PREFIX + '/bin/' + compilerName + 'ar'
env['RANLIB'] = PREFIX + '/bin/' + compilerName + 'ranlib'

if(TOOLSET == 'GCC710'):
    env['PROGSUFFIX'] = '.elf'
else:
    env['PROGSUFFIX'] = '.tos'

env['LIBSUFFIX'] ='.a'

# VASM
env['AS']='vasmm68k_mot'
env['VASM'] = env['AS']

# ST/e, F030, CT60 program flags
CFLAGS=''
LDFLAGS=''
VASM_FLAGS=''
CPPFLAGS=''
CXXFLAGS=''

LIB_POSTFIX='not_set'
LIB_TARGET='not_set'

STACK_SIZE=0
    
TARGET='-DTARGET_'
CSTARTUP_FOLDER=''

if(TOOLSET=='GCC434'):

	fpu_flags = ''
	
	if(use_fpu == 'yes'):
		fpu_flags = '-m68881 '
	else:
		fpu_flags = '-msoft-float '
		
	if(targetPlatform == 'ST'):
		CFLAGS += '-m68000 -std=c99 -ffast-math -fomit-frame-pointer ' + fpu_flags
		LDFLAGS += '-m68000 -Wl,--traditional-format '
		VASM_FLAGS += '-m68000 -quiet -Faout -quiet -spaces -I../include '
		CSTARTUP_FOLDER='../deps/startup/aout/m68000/'
		
		LIB_TARGET = '000'
	elif(targetPlatform == 'F030'):
		CFLAGS += '-m68030 -std=c99 -ffast-math -fomit-frame-pointer ' + fpu_flags
		LDFLAGS += '-m68030 -Wl,--traditional-format '
		VASM_FLAGS += '-m68030 -quiet -Faout -quiet -spaces -I../include'
		CSTARTUP_FOLDER='../deps/startup/aout/m68030/'

		LIB_TARGET = '030'
	elif(targetPlatform == 'CT60'):
		CFLAGS += '-m68060 -std=c99 -ffast-math -fomit-frame-pointer ' + fpu_flags
		LDFLAGS += '-m68060 -Wl,--traditional-format '
		VASM_FLAGS += '-m68060 -quiet -Faout -quiet -spaces -I../include'
		CSTARTUP_FOLDER='../deps/startup/aout/m68060/'

		LIB_TARGET = '060'
	else:
		print('Unsupported target. Exiting...')
		exit(-1)
elif(TOOLSET == 'GCC710'):

	if(use_fpu == 'yes'):
		fpu_flags = '-m68881 '
	else:
		fpu_flags = '-msoft-float '

	if(targetPlatform == 'ST'):
		CFLAGS += '-m68000 -std=c99 -fomit-frame-pointer -fleading-underscore -ffunction-sections -fdata-sections ' + fpu_flags
		LDFLAGS += '-m68000 -Wl,--gc-sections -Wl,--emit-relocs -Ttext=0 '
		VASM_FLAGS += '-m68000 -quiet -Felf -quiet -spaces -I../include '
		CSTARTUP_FOLDER = '../deps/startup/brownelf/m68000/'

		LIB_TARGET = '000'

		# floating point support
		env['LIBPATH'] = env['LIBPATH'] + ['/lib/gcc/m68k-ataribrowner-elf/7.1.0/m68000','/usr/m68k-ataribrowner-elf/lib/m68000']
	elif(targetPlatform == 'F030'):
		CFLAGS += '-m68030 -std=c99 -fomit-frame-pointer -fleading-underscore -ffunction-sections -fdata-sections ' + fpu_flags
		LDFLAGS += '-m68030 -Wl,--gc-sections -Wl,--emit-relocs -Ttext=0 '
		VASM_FLAGS += '-m68030 -quiet -Felf -quiet -spaces -I../include '
		CSTARTUP_FOLDER = '../deps/startup/brownelf/m68030/'

		LIB_TARGET = '030'
		
		# floating point support
		if(use_fpu == 'yes'):
			# hardware fpu support
			env['LIBPATH']=env['LIBPATH'] + ['/lib/gcc/m68k-ataribrowner-elf/7.1.0/m68020', '/usr/m68k-ataribrowner-elf/lib/m68020']
		else:
			# soft float
			env['LIBPATH']=env['LIBPATH'] + ['/lib/gcc/m68k-ataribrowner-elf/7.1.0/m68020/softfp', '/usr/m68k-ataribrowner-elf/lib/m68020/softfp']
	elif(targetPlatform == 'CT60'):
		CFLAGS += '-m68060 -std=c99 -fomit-frame-pointer -fleading-underscore -ffunction-sections -fdata-sections ' + fpu_flags
		LDFLAGS += '-m68060 -Wl,--gc-sections -Wl,--emit-relocs -Ttext=0 '
		VASM_FLAGS += '-m68060 -quiet -Felf -quiet -spaces -I../include '
		CSTARTUP_FOLDER='../deps/startup/brownelf/m68060/'

		LIB_TARGET = '060'
		
  		# floating point support
		# hardware fpu support
		env['LIBPATH'] = env['LIBPATH'] + ['/lib/gcc/m68k-ataribrowner-elf/7.1.0/m68060', '/usr/m68k-ataribrowner-elf/lib/m68060']
	else:
		print('Unsupported target. Exiting...')
		exit(-1)
else:
    print('ERROR: Undefined target toolset. Exiting...')
    exit(-1)

if(enable_lto == 'yes'):
	CFLAGS += '-flto '
	LDFLAGS += '-flto '
	
	
TARGET = TARGET + targetPlatform

# indicate that we are not linking to standard libc libraries
if(use_libc == "no"):
    LDFLAGS+='-nostdlib -nostartfiles -Wl,-e__start ' 
else:	
	LDFLAGS+='-Wl,-e__start ' 
		
# skip writing directly to ikbd port completely
if (tx_enable == "yes"):
    VASM_FLAGS += '-DTX_ENABLE=1 '
else:
    VASM_FLAGS += '-DTX_ENABLE=0 '

if (conout_enable == "no"):
    print "Silent mode. Console output disabled."
    CFLAGS += '-DSUPRESS_CON_OUTPUT '

if (gemdos_io_enable == "yes"):
    print "Use GEMDOS for file I/O not libc functions."
    CFLAGS += '-DENABLE_GEMDOS_IO '

# output executable name
OUTPUT_DIR='../bin/'
AMIDI_TEST_NAME = 'midiplay' 
YM2149_TEST_NAME ='ym2149' 
MIDI_SEQ_TEST_NAME = 'midiout'
TIMINGS_TEST_NAME = 'midiseq' 
NKT_REPLAY_NAME = 'nktrep' 
MID2NKT_NAME = 'mid2nkt' 
	
env["CPPPATH"] = env["CPPPATH"] + ["../","../include","../include/lzo","../include/ym2149","../include/input"]
env["LIBPATH"] = env["LIBPATH"] + ['../bin/','/usr/m68k-ataribrowner-elf/lib']
  
#############################################################################################################################
# additional defines  
#############################################################################################################################
# DEBUG_BUILD - enables debug build
# DEBUG_FILE_OUTPUT enables log output to files (works only if DEBUG_BUILD is defined)  
# DEBUG_CONSOLE_OUTPUT enables log output to console (works only if DEBUG_BUILD is defined)  
# DEBUG_SERIAL_OUTPUT debug enables output to serial port (works only if DEBUG_BUILD is defined)
# DEBUG_MEM logs memory function calling (works only if DEBUG_BUILD && (DEBUG_FILE_OUTPUT||DEBUG_CONSOLE_OUTPUT) is enabled)
# FORCE_MALLOC forces use of libc malloc() for memory allocation, not native functions
# MIDI_PARSER_DEBUG output midi parsing (works only if DEBUG_BUILD && (DEBUG_FILE_OUTPUT||DEBUG_CONSOLE_OUTPUT) is enabled)
# MIDI_PARSER_TEST outputs loaded and parsed midi file in human readable form
# IKBD_MIDI_SEND_DIRECT all Midiws() calls will be replaced with low level function that writes to hardware.
# USE_INLINE if defined some functions are inlined
# EVENT_LINEAR_BUFFER library uses custom memory pool for midi events instead of using standard memory allocation calls (per sequence file),
# memory pool is configurable (see eventPoolSize / eventDataAllocatorSize)
# LZO_DEBUG enables LZO debug mode

if ( build_mode == 'debug'):
  print "Debug build..."
  if(debug_level=='1'):
    CFLAGS += '-DDEBUG_BUILD -DEVENT_LINEAR_BUFFER ' + '-DUSE_INLINE '  + '-DDEBUG_SERIAL_OUTPUT ' + '-DLOAD_TEST '
  elif(debug_level=='2'):
    CFLAGS += '-DDEBUG_BUILD -DMIDI_PARSER_DEBUG -DMIDI_PARSER_TEST -DEVENT_LINEAR_BUFFER '
  elif(debug_level=='3'):
    CFLAGS += '-DDEBUG_BUILD -DEVENT_LINEAR_BUFFER '
  else:
	CFLAGS += '-DDEBUG_BUILD -DEVENT_LINEAR_BUFFER ' + '-DUSE_INLINE ' + '-DDEBUG_SERIAL_OUTPUT ' + '-DLOAD_TEST '
  
  LIB_POSTFIX = LIB_TARGET+'d' 
else:
	print "Release build... Code optimisation is turned on."
	CFLAGS += '-DEVENT_LINEAR_BUFFER ' +' -O2 ' + ' -DUSE_INLINE '
	LIB_POSTFIX = LIB_TARGET 
    
if(ikbd_direct_write == "yes"):
    print "Sending data directly via IKBD ENABLED"
    CFLAGS += '-DIKBD_MIDI_SEND_DIRECT '
    VASM_FLAGS += '-DIKBD_MIDI_SEND_DIRECT=1 '
elif(ikbd_direct_write=='no'):
    print "Sending data directly via IKBD DISABLED"
    CFLAGS += ' '
    VASM_FLAGS += '-DIKBD_MIDI_SEND_DIRECT=0 '

env["CFLAGS"] = CFLAGS  
env["LINKFLAGS"] = LDFLAGS 
env["ASFLAGS"] = VASM_FLAGS
env['VASM_FLAGS'] = VASM_FLAGS

# core functionality
core_src = ["common/core/c_vars.c","common/core/amlog.c","common/core/amidilib.c","common/core/config.c","common/core/list.c"]
roland_src = ["common/roland/rol_ptch.c","common/roland/rol_tbl.c"]
nkt_format_src = ["common/formats/seq2nkt.c","common/formats/midi2nkt.c","common/formats/nkt_rep_m68k.s","common/formats/nkt_rep.c"]
midiformats_src = ["common/formats/iff.c","common/formats/mus2midi.c"] + nkt_format_src
midiparser_src = ["common/midi/mparser.c"]

m68kasm_common_src = ["tos/common.s"]
input_src =  ["tos/ikbd.s"]
discio_src = ["tos/discio/fmio.c"]
timing_src = ["tos/timing/mfp.c","common/timing/miditim.c","tos/common.s"]
midi_src = ["tos/midi/midi_rep.c","common/midi/midiseq.c","common/midi/midi.c","tos/common.s","tos/midiReplay.s"]
memory_src = ["tos/memory/memory.c","common/memory/stack.c","common/memory/linalloc.c"]

# other: native keyboard input (Atari only), ym2149 output, random functions, lzo compression
ym2149_src = ["common/ym2149.c"]
lzo_src = ["common/lzo/minilzo.c"]

# main library 
amidilib_src = core_src + discio_src + memory_src + timing_src + midi_src + midiparser_src + roland_src + midiformats_src + lzo_src

# build library
env.Library(LIBRARYNAME + LIB_POSTFIX, amidilib_src)

#################### test programs entry points
amidi_test_src = ["../demo/midi_rep/main.c"] 
midiOut_test_src = ["../demo/midi_output/midiTest.c"]
timings_test_src = ["../demo/timings/timTest.c","../demo/timings/sampleSequence.c","tos/testReplay.s"]
ym2149_test_src = ["../demo/ymOutput/ymTest.c"]
nktReplay_src = ["../demo/nktReplay/nktReplay.c"]
mid2nkt_src = ["../demo/mid2nkt/mid2nkt.c"]

##################### nkt
nkt_src = ["common/core/c_vars.c","common/core/amlog.c","common/roland/rol_ptch.c","common/formats/midi2nkt.c","common/formats/mus2midi.c","common/formats/midiInfo.c","common/formats/nkt_rep_m68k.s","common/formats/nkt_rep.c" ]

if (gemdos_io_enable == "yes"):
    nkt_src = nkt_src + discio_src

ADDLIBS=['']
	
if(use_libc=="no"):
	objPostfix = ''
	
	if ( build_mode == 'debug'):
			objPostfix='d.o'
	else:
			objPostfix='.o'
	
	libAbsPath = Dir('../').abspath
	libDirPrefixPath=''
	
	startup_obj = [CSTARTUP_FOLDER + 'mStartupAsmC' + objPostfix, CSTARTUP_FOLDER +'mStartup' + objPostfix, CSTARTUP_FOLDER + 'stdlib' + objPostfix]
	
	# build test programs and link them with amidilib and custom startup code
	env.Program(target = (AMIDI_TEST_NAME + env['PROGSUFFIX']), source = [startup_obj + amidi_test_src + env.Object(input_src)] , LIBS = ADDLIBS + [LIBRARYNAME + LIB_POSTFIX], PROGSUFFIX = env['PROGSUFFIX'])
	env.Program(target = (MIDI_SEQ_TEST_NAME + env['PROGSUFFIX']),source =  [startup_obj + midiOut_test_src + env.Object(input_src)], LIBS = ADDLIBS + [LIBRARYNAME + LIB_POSTFIX], PROGSUFFIX = env['PROGSUFFIX'])
	env.Program(target = (YM2149_TEST_NAME + env['PROGSUFFIX']), source = [startup_obj + ym2149_test_src + env.Object(m68kasm_common_src) + env.Object(input_src) + env.Object(ym2149_src)],  LIBS = ADDLIBS + [LIBRARYNAME + LIB_POSTFIX], PROGSUFFIX=env['PROGSUFFIX'])
	env.Program(target = (TIMINGS_TEST_NAME + env['PROGSUFFIX']),source =  [startup_obj + timings_test_src  + env.Object(m68kasm_common_src)+ env.Object(input_src) + env.Object(ym2149_src)], LIBS = ADDLIBS + [LIBRARYNAME + LIB_POSTFIX], PROGSUFFIX=env['PROGSUFFIX'])
	env.Program(target = (NKT_REPLAY_NAME + env['PROGSUFFIX']),source =  [startup_obj + nktReplay_src + env.Object(nkt_src) + env.Object(input_src) + env.Object(timing_src) + env.Object(memory_src) + env.Object(lzo_src)] , LIBS = ADDLIBS + [], PROGSUFFIX=env['PROGSUFFIX']);
	env.Program(target = (MID2NKT_NAME + env['PROGSUFFIX']),source =  [startup_obj + mid2nkt_src +  env.Object(nkt_src)  + env.Object(timing_src)+ env.Object(memory_src) + env.Object(lzo_src) ] , LIBS= ADDLIBS + [], PROGSUFFIX = env['PROGSUFFIX']);
else:
	# build test programs and link them with amidilib
	startup_obj=['']
	if(TOOLSET == 'GCC710'):
	    ADDLIBS = ['c']
	    startup_obj = ['/usr/m68k-ataribrowner-elf/lib/crt0.o']

	env.Program(target = (AMIDI_TEST_NAME + env['PROGSUFFIX']), source = [startup_obj + amidi_test_src + env.Object(input_src)] , LIBS = ADDLIBS + [LIBRARYNAME + LIB_POSTFIX] , PROGSUFFIX = env['PROGSUFFIX'])
	env.Program(target = (MIDI_SEQ_TEST_NAME + env['PROGSUFFIX']), source = [startup_obj +midiOut_test_src + env.Object(input_src)], LIBS = ADDLIBS + [LIBRARYNAME + LIB_POSTFIX], PROGSUFFIX = env['PROGSUFFIX'])
	env.Program(target = (YM2149_TEST_NAME + env['PROGSUFFIX']), source = [startup_obj +ym2149_test_src + env.Object(m68kasm_common_src) + env.Object(input_src) + env.Object(ym2149_src)], LIBS =ADDLIBS + [LIBRARYNAME + LIB_POSTFIX], PROGSUFFIX = env['PROGSUFFIX'])
	env.Program(target = (TIMINGS_TEST_NAME + env['PROGSUFFIX']), source = [startup_obj +timings_test_src  + env.Object(m68kasm_common_src)+ env.Object(input_src) + env.Object(ym2149_src)], LIBS =ADDLIBS + [LIBRARYNAME + LIB_POSTFIX], PROGSUFFIX = env['PROGSUFFIX'])
	env.Program(target = (NKT_REPLAY_NAME + env['PROGSUFFIX']), source = [startup_obj +nktReplay_src + env.Object(nkt_src) + env.Object(input_src) + env.Object(timing_src) + env.Object(memory_src) + env.Object(lzo_src)] , LIBS=ADDLIBS + [''], PROGSUFFIX = env['PROGSUFFIX']);
	env.Program(target = (MID2NKT_NAME + env['PROGSUFFIX']), source = [startup_obj +mid2nkt_src +  env.Object(nkt_src)  + env.Object(timing_src)+ env.Object(memory_src) + env.Object(lzo_src) ] , LIBS=ADDLIBS + [''], PROGSUFFIX = env['PROGSUFFIX']);

	OutDirPath = Dir('../').abspath
	if(TOOLSET == 'GCC710'):
		convertElf(AMIDI_TEST_NAME, build_mode, OutDirPath, '.ttp')
		convertElf(MIDI_SEQ_TEST_NAME, build_mode, OutDirPath,'.tos')
		convertElf(YM2149_TEST_NAME, build_mode, OutDirPath,'.tos')
		convertElf(TIMINGS_TEST_NAME, build_mode, OutDirPath, '.tos')
		convertElf(NKT_REPLAY_NAME, build_mode, OutDirPath, '.ttp')
		convertElf(MID2NKT_NAME, build_mode, OutDirPath, '.ttp')
		
# add stripping symbols
# add copy/install/deploy step 	
	
